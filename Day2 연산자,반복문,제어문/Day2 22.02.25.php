<style>body{font-size: xx-large;}</style>
<title>php 기본문법</title>
<body>
<?php
// 연산자
    // 산술 연산자
    /*
     * +    왼쪽의 피연산자에게 오른쪽의 피연산자를 더함
     * -    왼쪽의 피연산자에게 오른쪽의 피연산자를 뺌
     * *    왼쪽의 피연산자에게 오른쪽의 피연산자를 곱함
     * /    왼쪽의 피연산자에게 오른쪽의 피연산자로 나눔
     * %    왼쪽의 피연산자에게 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함
     * **   왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 제곱함
     */
    $num_01 = 10;
    $num_02 = 4;
    echo "10 + 4 = ".($num_01 + $num_02)."<br/>";      // 14
    echo "10 - 4 = ".($num_01 - $num_02)."<br/>";       // 6
    echo "10 * 4 = ".($num_01 * $num_02)."<br/>";       // 40
    echo "10 / 4 = ".($num_01 / $num_02)."<br/>";       // 2.5
    echo "10 % 4 = ".($num_01 % $num_02)."<br/>";       // 2
    echo "10 ** 4 = ".($num_01 ** $num_02)."<br/>";     // 10000
    // 대입연산자
        /*
         * 대임연사자
         * =    왼쪽의 피연산자에 오른쪽의 피연산자를 대입함.ㅌ
         */
        /*
         * 복합연사자
         * +=   왼쪽의 피연산자에게 오른쪽의 피연산자를 더한 후, 왼쪽의 피연산자에 대입함
         * -=   왼쪽의 피연산자에게 오른쪽의 피연산자를 뺀 후, 왼쪽의 피연산자에 대입함
         * *=   왼쪽의 피연산자에게 오른쪽의 피연산자를 곱한 후, 왼쪽의 피연산자에 대입함
         * /=   왼쪽의 피연산자에게 오른쪽의 피연산자로 나눈 후, 왼쪽의 피연산자에 대입함
         * %=   왼쪽의 피연산자에게 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함
         * .=   왼쪽 피연산자의 문자열에 오른쪽 피연산자의 문자열을 추가한 후, 왼쪽의 피연산자에 대입함
         * <<=  왼쪽의 피연산자의 비트를 오른쪽의 피연산자만큼 전부왼쪽으로 이동시킨 후, 그 결과를 왼쪽의 피연산자에 대입함
         * >>=  왼쪽의 피연산자의 비트와 부호를 유지하면서 오른쪽의 피연산자만큼 전부 오른쪽으로 이동시킨 후, 그 결과를 왼쪽의 피연산자에 대입함
         * &=   왼쪽 피연산자의 논리식과 오른쪽 피연산자의 논리식이 모두 true이면 왼쪽의 피연산자에 true를 대입하고, 그 외에는 false를 대입함
         * !=   왼쪽 피연산자의 논리식이나 오른쪽 피연산자의 논리식이 중 하나라도 true이면 왼쪽의 피연산자에 true를 대입하고, 그 외에는 false를 대입함
         * ^=   왼쪽 피연산자의 논리식과 오른쪽 피연산자의 논리식이 서로 다르면 왼쪽의 피연산자에 true를 대입하고, 그 외에는 false를 대입함.
         */
    // 증감 연산자
        /*
         * 증감연산자
         * ++$var   먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 수행함
         * $var++   먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴
         * --$var   먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 수행함
         * $var--   먼저
         */
    // 비교 연산자
        /*
         * 비교 언산자
         * ==   왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 참을 반환함
         * ===  왼쪽의 피연산자와 오른쪽의 피연산자가 같고, 같은 타입이면 참을 반환함
         * !=   왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 참을 반환함
         * <>   왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 참을 반환함
         * !==  왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않거나, 타입이 다르면 참을 반환함
         * <    왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 참을 반환함
         * <=   왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 참을 반환함
         * >    왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 참을 반환함
         * >=   왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 참을 반환함.
         */
        /*
         * 다양한 타입의 비교
         * bool, null
         * 모두
         * 둘 다 불리언으로 변환한 후 비교함.
         * string, resource, integer, float
         * string, resource, integer, float
         * 숫자로 시작하는 문자열과 리소스는 숫자로 변환한 후 비교함
         * object
         * object
         * 내장 클래스는 자신의 비교 함수를 정의할 수 있으나, 다른 클래스끼리 비교할 수는 없음
         * array
         * array
         * 배열끼리의 비교는 같은 키를 가지는 값을 서로 비교함 이때 피연산자1 배열의 키가 피연산자2 배열에 존재하지 않으면 비교할 수 없으며, 배열 요소의 수가 적은 쪽이 작다고 판단됨
         * array
         * 모두
         * 배열이 항상 크다고 판단됨
         * object
         * 모두
         * 객체가 항상 크다고 판단됨
         */
    // 논리 연산자
    /*
     * and  논리식이 모두 참이면 참을 반환함. (AND 연산)
     * or   논리식 중에서 하나라도 참이면 참을 반환함. (OR 연산)
     * xor  논리식이 서로 다르면 참을 반환함. (XOR 연산)
     * &&   논리식이 모두 참이면 참을 반환함. (AND 연산)
     * ||   논리식 중에서 하나라도 참이면 참을 반환함. (OR 연산)
     * !    논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함. (NOT 연산)
     *
     * A        B       A and B (A && B)        A or B (A || B)     A xor B     !A
     * true     true    true                    true                false       false
     * true     false   false                   true                true        false
     * false    true    false                   true               	true	    true
     * false	false	false	                false	            false   	true
     */
    // 비트 연산자
    /*
     * &    대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)
     * |    대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)
     * ^    대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)
     * ~    비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산)
     * <<   지정한 수만큼 비트를 전부 왼쪽으로 이동시킴. (left shift 연산)
     * >>   부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산)
     */
    // 기타 연산자
        // 삼항 연사자
        /*
         * 문자열 연산자(.)를 사용하여 문자열을 연결할 수 있다 또한, echo() 함수에서는 쉼표 연산자(,)를 이용하여 문자열을 연결할 수 있다
         */
        $num_01 = 10;
        $num_02 = 4;
        $result = ($num_01 > $num_02) ? $num_01 : $num_02;
        echo "둘 중에 더 큰 수는 {$result} 입니다.";
        // 문자열 연산자
        $str_01 = "Hello";
        $str_02 = "World";
        echo $str_01.$str_02."<br/>";
        echo $str_01,$str_02;
        // 배열 합집합 연산자
        /*
         * 배열 합집합 연산자(+)는 피연산자로 오는 두 배열의 합집합을 반환 왼쪽 피연산자의 배열의 키 값 유지하면서, 오른쪽 피연산자의 배열을 덧붙이는 방식을 취한다
         */
        // 키값 동일시
        $arr_01 = array("1st" => "PHP", "2nd" => "MySQL");
        $arr_02 = array("1st" => "HTML", "2nd" => "CSS", "3rd" => "JavaScript");
        $result_01 = $arr_01 + $arr_02; // [PHP, MySQL, JavaScript]
        var_dump($result_01);
        $result_02 = $arr_02 + $arr_01; // [HTML, CSS, JavaScript]
        var_dump($result_02);
        // 키값 다를때
        $arr_01 = array("1" => "PHP", "2" => "MySQL");
        $arr_02 = array("3" => "HTML", "4" => "CSS", "5" => "JavaScript");
        $result_01 = $arr_01 + $arr_02; // [PHP, MySQL, HTML, CSS, JavaScript]
        var_dump($result_01);
        $result_02 = $arr_02 + $arr_01; // [HTML, CSS, JavaScript, PHP, MySQL]
        var_dump($result_02);
        // 키값을 명시하지 않을 때
        $arr_01 = array("PHP", "MySQL");
        $arr_02 = array("HTML", "CSS", "JavaScript");
        $result_01 = $arr_01 + $arr_02; // [PHP, MySQL, JavaScript]
        var_dump($result_01);
        $result_02 = $arr_02 + $arr_01; // [HTML, CSS, JavaScript]
        var_dump($result_02);
        // instanceof 연산자
        /*
         * 해당 변수가 어떤 클래스(class)에서 생성된 객체(object)인지를 확인할 때
         * 해당 변수가 부모 클래스(parent class)에서 상속받은 클래스인지를 확인할 때
         * 해당 변수가 클래스의 인스턴스(instance)인지 아닌지를 확인할 때
         * 해당 변수가 인터페이스(interface)로 구현한 클래스의 객체 인스턴스(object instance)인지 아닌지를 확인할 때
         */
        interface Interface01{}
        class Class01{}
        class Class02 extends Class01 implements Interface01{}
        /* 어떤 클래스(class)에서 생성된 객체(object)인지를 확인할 때 */
        $var_01 = new Class01; // Class01 클래스 객체를 생성함.
        var_dump($var_01 instanceof Class01); // true
        var_dump($var_01 instanceof Class02); // false
        /* 부모 클래스(parent class)에서 상속받은 클래스인지를 확인할 때 */
        $var_02 = new Class02; // Class02 클래스 객체를 생성함.
        var_dump($var_02 instanceof Class01); // true
        var_dump($var_02 instanceof Class02); // true
        /* 클래스의 인스턴스(instance)인지 아닌지를 확인할 때 */
        $var_03 = new Class01; // Class01 클래스 객체를 생성함.
        var_dump(!($var_03 instanceof Class02)); // true
        /* 인터페이스(interface)로 구현한 클래스의 객체 인스턴스(object instance)인지 아닌지를 확인할 때 */
        $var_04 = new Class02; // Class02 클래스 객체를 생성함.
        var_dump($var_04 instanceof Class02); // true
        var_dump($var_04 instanceof Interface01); // true

// 제어문
    // 조건문
        // if
        /*
        if (조건식1) {
            조건식1의 결과가 참일 때 실행하고자 하는 명령문;
        }
        */
        // else
        /*
        if (조건식1) {
            조건식1의 결과가 참일 때 실행하고자 하는 명령문;
        }
        else {
            조건식1의 결과도 거짓이고, 조건식2의 결과도 거짓일 때 실행하고자 하는 명령문;
        }
        */
        // else if
        /*
        if (조건식1) {
            조건식1의 결과가 참일 때 실행하고자 하는 명령문;
        }
        else if (조건식2) {
            조건식2의 결과가 참일 때 실행하고자 하는 명령문;
        }
        else {
            조건식1의 결과도 거짓이고, 조건식2의 결과도 거짓일 때 실행하고자 하는 명령문;
        }
        */
        // switch
        /*
         * switch문은 if-else문과 마찬가지로 주어진 조건 값에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문
         * switch문은 if-else문보다 가독성 측면에서 더 좋다
         * 참고로 case절의 값은 일치 연산자(===)가 아닌 동등 연산자(==)를 사용하여 느슨하게 비교
         * 그리고 어떠한 case 절에도 해당하지 않을 경우 default 절이 실행
         * 각 case절 및 default 절은 반드시 break 키워드를 포함하고 있어야 함 (switch 탈출을 위해!)
         */
        /*
        switch (조건 값)
        {
            case 값1:
                조건 값이 값1일 때 실행하고자 하는 명령문;
                break;
            case 값2:
                조건 값이 값2일 때 실행하고자 하는 명령문;
                break;
            ...
            default:
                해당 case가 없을 때 실행하고자 하는 명령문;
                break;
        }
        */

    // 반복문
        // while
        /*
        while (조건식) {
            조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
        }
        */
        // for
        /*
        for (초기식; 조건식; 증감식) {
            조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
        }
        */
        // foreach
        /*
         * foreach문은 배열의 모든 요소를 손쉽게 순회할 수 있도록 해준다
         * 이 반복문은 루프마다 배열의 각 요소를 지정된 변수에 대입한다
         * 이렇게 대입받은 변수를 이용하면 루프 안에서 배열의 각 요소에 순차적으로 접근할 수 있다
         * 따라서 foreach문은 배열의 길이만큼 반복된다
        foreach (배열 as 값을 저장할 변수) {
            실행하고자 하는 명령문;
        }
        */
    // 기타
        // continue
        /*
         * continue문은 루프 내에서 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단으로 넘어감
         * 보통 반복문 내에서 특정 조건에 대한 처리를 제외하고자 할 때 사용된다
         */
        $var = 2;
        for ($i = 0; $i < 10; $i++) {
            if ($i % 2 == 0) // 짝수 제외
                continue;
            echo "{$i}<br/>";
        }
        // break
        $var = 2;
        $i = 0;
        $sum = 0;
        while (true) {
            if ($i == $var)
                break;
            $sum += $i; $i++;
        }
        echo $sum;
        // goto
        /*
         * goto문은 프로그램의 흐름을 지정된 레이블로 무조건 변경하는 명령문
         * goto는 다른 제어문과 다르게 아무 조건 없이 제어를 옮겨주기 때문에, 프로그램 흐름을 매우 복잡하게 만들 수도 있다
         * 이러한 단점으로 인해 현재는 거의 사용하지 않는다
         */
?>
</body>
